{"componentChunkName":"component---src-templates-docs-js","path":"/frontend-web/typescript/type-vs-interface","result":{"data":{"site":{"siteMetadata":{"title":".NET Thailand","docsLocation":"https://github.com/dotnetthailand/dotnetthailand.github.io","docsRepo":"dotnetthailand/dotnetthailand.github.io","docsLocationType":"github","editable":true,"contentRootPath":"content","siteUrl":"https://www.dotnetthailand.com"}},"mdx":{"fields":{"id":"81edebaa-5c9f-5846-823c-241897c9c563","title":"Type VS Interface","slug":"/frontend-web/typescript/type-vs-interface"},"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Type VS Interface\",\n  \"showMetadata\": true,\n  \"editable\": true,\n  \"showToc\": true,\n  \"order\": 2\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://stackoverflow.com/a/65948871/1872200\"\n  }, \"https://stackoverflow.com/a/65948871/1872200\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#differences-between-type-aliases-and-interfaces\"\n  }, \"https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#differences-between-type-aliases-and-interfaces\"))), mdx(\"section\", null, mdx(\"h1\", {\n    parentName: \"section\"\n  }, \"Type or Interface for React props\"), mdx(\"ul\", {\n    parentName: \"section\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://dev.to/reyronald/typescript-types-or-interfaces-for-react-component-props-1408\"\n  }, \"https://dev.to/reyronald/typescript-types-or-interfaces-for-react-component-props-1408\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/basic_type_example/#more-advice\"\n  }, \"https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/basic_type_example/#more-advice\"))), mdx(\"p\", {\n    parentName: \"section\"\n  }, \"Types declarations are almost always more concise than their interface counterparts because of their syntax, and they can also be more composable thanks to the possibility of unions. If the prop object you are typing is really small you can get away with inlining it in the function declaration too, which you wouldn't be able to do if you are strictly sticking to interfaces.\"), mdx(\"p\", {\n    parentName: \"section\"\n  }, \"When it comes to re-usable libraries, using interfaces instead is a very good and pragmatic choice as it allows the library itself to be more flexible because now each consumer can re-declare each of those interfaces as needed to add properties.\"), mdx(\"p\", {\n    parentName: \"section\"\n  }, \"If you work on a multi-team company, all team use and contribute a component that you own.\\nYou decided to use interfaces because you can re-declare an interface, it's very likely that when another team encounters a typing inconsistency issue they decide to quickly fix it in their code bases by leveraging the flexibility of extension points rather than contributing a fix upstream, and further fragmenting the consistency of the development experience across the company as a result.\")));\n}\n;\nMDXContent.isMDXComponent = true;","tableOfContents":{"items":[{"url":"#type-or-interface-for-react-props","title":"Type or Interface for React props"}]},"timeToRead":1,"parent":{"__typename":"File","relativePath":"frontend-web/typescript/type-vs-interface.md"},"frontmatter":{"metaTitle":null,"showMetadata":true,"editable":true,"showPreviousNext":null,"showToc":true}},"gitBranch":{"name":"main"},"gitCommit":{"hash":"d8cc45e74ec87b664a5c7f2ad7a707af6edac455","date":"2021-09-20 03:20"}},"pageContext":{"id":"81edebaa-5c9f-5846-823c-241897c9c563"}},"staticQueryHashes":["12478684","12478684","1306071104","2353585426","2353585426","2552263575","2552263575","2882937274","2882937274","353167761","353167761","3812332637","3812332637","4285724809"]}